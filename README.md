## Go's variable types
- Go is a statiscally typed language 
- All variables have assigne  types
- You can set types explicitly or implicitly

1. Boolean values: bool 
2. String type: string 
3. Fixed integer types: uint8, uint16, uint32, uint64, int8, int16, int32, int64
4. Aliases can be used instead of full type names: byte uint int uintptr 
5. Floating values: float32, float64 
6. Complex numbers: complex64, complex128
7. Data collections: Arrays, Slices, Maps, Struct 
8. Language organization: Functions, Interfaces, Channels 
9. Data management: Pointers 


- [Instructor] As with all programming languages you can store data in memory in Go using variables. Go is a statically typed language. That means that each variable must be assigned to type and once assigned it can't be changed. You can set types for each variable either explicitly, by naming the type in the variable declaration or implicitly, by allowing the compiler to infer the type based on a value that you initially assign. Go comes with a set of built-in data types. You can also define your own data types but these are the ones that are always available to you. The first type is bool, for Boolean. This is a simple true, false value and the only two values that you can assign are true and false. String types are collections of characters. A variable with the type of string contains a series of characters. We'll be talking about strings a lot. Integers come in a variety of flavors. These are the fixed integer types. They each declare either an unsigned or assigned integer and the numeric value in the name is the number of bits. That affects the range or the highest and lowest values that you can assign. There's also a set of type aliases, the byte, the unsigned int, the int and the unsigned int pointer. The int and unsigned int data types are interesting. They reflect either a 32 or a 64 bit value depending on what operating system you're running on. On macOS and on 64 bit windows these are the same as an int64 and a uint64. But, if you run exactly the same code in the Go playground those become 32 bit values because of the underlying operating system. Here are some other built-in numeric types. There are two floating types, float32 and float64. And, once again, the numeric values in the names indicate the number of bits used for storage and therefore, the range that's available to you. And then there are what are known as the complex types, complex64 and complex128. A complex number contains two parts, real numbers and imaginary numbers. Now, if that sounds complicated don't worry about it we won't be using those in this beginning course, but if you understand the concept of complex numbers these types are available. And then there are also built-in types for data collections. There are Arrays and Slices to manage order data collections and Maps and Structs to manage aggregations of values. There are also types that deal with language organization. These exist in other languages but aren't always considered types in those languages. In Go, a function is a type and that's what makes it possible to take a function and pass it into another function as an argument. Interfaces and Channels are also types in Go's and Go also supports pointers, reference variables that point to an address in memory to refer to another value. These are the built-in types in Go but they're just the beginning point, because again, you can create your own data types in this language.


## How memory is allocated and managed

Memory is managed by the Runtime
- The Go runtime is statically linked into application
- Memory is allocated and deallocated automatically
- Use make() or new() to initialize maps, slices, and channels 

Memory allocation 
- The new() function 
    - Allocates but does not initialize the memory
    - Results in zeroed storage but retunrs a memory address 
- The make() function 
    - Allocates and initializes the memory
    - Allocates non-zeroed storage and returns a memory address 

Memory deallocation
- Memory is deallocated by garbage collector  (GC)
- Objects out of scope or set to nil are eligble 
- GC was rebuilt inGO 1.5 for very low latency 


- [Instructor] When you run a Go application with the go run command, you're depending on the Go runtime that's installed on your computer. And when you compile and build a binary Go application, the runtime is included. Either way, your application depends on the runtime which operates in the background in dedicated threads. Like other managed languages, such as Java and C#, you don't have to explicitly allocate or de-allocate memory in your code; it's all managed for you in the background. When you use complex types, such as maps, that is collections of key value pairs, you have to initialize them correctly. There are two built-in functions to be aware of called make() and new(), and you'll use them to initialize these complex objects. There's a difference between them though. The new() function allocates, but doesn't initialize memory. When you allocate an object using the new() function, you'll get back a memory address indicating the location of the map, but the map object itself has zeroed memory storage. And if you try to add a key value pair to the map, it'll cause an error. In contrast, the make() function both allocates and initializes memory. You'll get back that memory address just like you do with new(), but the storage is non-zero and is ready to accept values. Let's take a look at this bit of code. The first line declares a map object named M and says that the keys are strings and the associated values are integers. And I'm declaring that with the new() function. On the next line, I try to add a key value pair, known as an entry, to the map. I create a new value with the key named "theAnswer" and a value of 42. And then I try to output the contents of the map, but I'm not going to get to that third line of code. Instead, the app will crash and I'll see a panic error. It's telling me that I'm dealing with a map with zero memory storage. There's just no place to put the data. And so there's a panic and the application crashes. To fix this, wrap your declaration in the make() function which does initialize memory. In this version of the code, I'm once again saying that it's a map object that contains strings as keys and int as values, but this time, I initialize with make(), and now when I try to add an entry, it'll succeed. And when I output it, I get this output. So whenever you use these complex objects, it's critical that you wrap the initialization in the make() function if your intent is to immediately add data to the object. Memory is de-allocated automatically by the garbage collector that's built into the Go runtime. The garbage collector runs in the background and each time it kicks in, it looks for objects that are out of scope or set to nil so it can clean out the memory and return that memory to your memory pool. The garbage collector was completely rebuilt in Go 1.5 for very low latency to reduce the pauses that happen when you're running Go applications. And now, the process for de-allocating memory goes by so quickly that you're very unlikely to notice it, even on slower computers. Here are some links to some more information about garbage collection. You can find a lot of details in the developer documentation under the runtime package and, after the release of version 1.5, the talk referenced in the second URL has lots of technical details about low-latency garbage collection in Go.

## Reference values with pointers

- [Instructor] Like C and similar languages, Go supports the use of pointers: Variables that store the memory address of another variable. You can declare a pointer with a particular type, but you don't have to point it at an initial variable. I'm working in the main function of my main.go file in the practice directory. And in this branch, I'm starting off with a brand new application. Above the output command, I'll declare a new variable using the VAR keyword. I'll name it P for pointer and I'll set its type to * int. The asterisk means this is a pointer, not a value. And if I don't assign anything, that means that that variable will be nil; it doesn't contain anything. Now I'll change my output command. I'll start with a label of value of P and then after a comma, I'll output P. If I just name the pointer variable like this and then run the application, I'll get an output that says that's a nil variable. But if I add the asterisk before the variable name, meaning, "Hey, this is a pointer "and I'm pointing at some other variable," then I'll crash the application because P is pointing at an invalid memory address. So that's what happens with a pointer that isn't pointing at anything. Now, let's see what happens with a pointer that's pointing at a valid variable. I'll create a new variable at the top of the code that I'll name anInt, and I'll set its value with colon equals to a literal value of 42, an integer. Now I'll change this code. I'll once again start with var p and then I'll say that equals &anInt. The ampersand character means I'm pointing at the memory address of the variable, not at its value. And when I run that code, I see accurately that the value of P is 42, and that's because it's pointing at the value variable. Here's another example. I'll start with a floating point value. I'll create value1. I'll set it to a value of 42.13. Then I'll create a new variable called pointer1 And this time I'll use the colon equals syntax and I'll point it at &value1. Now I'm not explicitly declaring the type of pointer1, but because I use the ampersand, I'm pointing at the memory address of value1, not the value. To output this value using the pointer, I'll use a label of Value 1 and then *pointer1 and the asterisk says, "This is a pointer, "and I'm pointing at this other variable." And I get that value. So now let's see what happens if you try to change a value through the pointer and how it affects the original variable. I'll say *pointer1 = *pointer1 and I'll divide that say by 31; could be any number. Then I'll copy and paste this line of code. And I'm going to do it twice. The first time I'll say, this is the value if I address the pointer, and the second time I will address the value directly with value1. I'll run the code and I'll show that when I change the value through the pointer, I'm also changing the value that it's pointing at. If you're coming to Go from Java or C#, this is very similar to those languages' reference variables. If you're coming to Go from, say, Java, this is very similar to that language's reference variables. If you have an original variable and then a reference variable that points at that reference variable, you can change that variable either by changing the original variable or by changing the variable that's pointing at it. But unlike in Java, the pointer doesn't have to point at any particular value initially and you can change it at runtime to point from one value to another. If you're used to pointers in C, C# and other similar languages, you'll find pointers in Go are very similar and just as valuable.